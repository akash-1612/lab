<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AES (128-bit) Encrypt/Decrypt with Steps</title>
  <style>
    body{
      font-family: Arial, sans-serif;
      margin: 32px;
      background:#f5f6fa;
      display:flex;
      align-items:flex-start;
      justify-content:center;
    }
    .box{
      background:#fff;
      padding:26px 24px;
      border-radius:14px;
      box-shadow:0 2px 10px #eee;
      width: 980px;
      max-width: 96vw;
    }
    textarea,input{
      width:100%;
      padding:10px 12px;
      border:1.2px solid #cdd4ed;
      border-radius:8px;
      font-size: 14px;
      background:#f8faff;
      box-sizing:border-box;
    }
    label{ display:block; margin-top:12px; margin-bottom:6px; font-weight:700; }
    .row{ display:flex; gap:12px; flex-wrap:wrap; }
    .col{ flex:1; min-width: 280px; }
    button{
      padding:10px 16px;
      border:none;
      border-radius:8px;
      cursor:pointer;
      color:white;
      background:#4CAF50;
      margin-top:14px;
      margin-right:10px;
    }
    button.secondary{ background:#4CAF50; }
    button.ghost{ background:#6b7280; }
    .hint{ color:#334155; font-size: 13px; margin-top:6px; }
    .result{
      margin-top:14px;
      padding:12px;
      border:1px solid #d0d7fa;
      border-radius:10px;
      background:#fbfdff;
      word-break:break-word;
    }
    .steps{
      margin-top:14px;
      padding:12px;
      border:1px solid #ccd8ff;
      border-radius:10px;
      background:#f9faff;
      font-size:13px;
      line-height:1.65;
      overflow:auto;
      max-height: 55vh;
    }
    .step-block{ margin: 10px 0; padding:10px; border:1px dashed #c7d2fe; border-radius:10px; background:white; }
    .steptitle{ font-weight:800; }
    code{ background:#f1f5ff; padding:2px 6px; border-radius:6px; }
    table{ border-collapse:collapse; margin-top:8px; }
    td{ border:1px solid #cbd5e1; padding:4px 6px; text-align:center; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; }
  </style>
</head>
<body>
  <div class="box">
    <h2>AES-128 (Educational) Encrypt/Decrypt with Steps</h2>

    <div class="row">
      <div class="col">
        <label for="key">Key (16 chars / 16 bytes for AES-128)</label>
        <input id="key" type="text" value="Thats my Kung Fu" maxlength="64" />

        <label for="plain">Plaintext</label>
        <textarea id="plain" rows="4">Two One Nine Two</textarea>

        <button class="secondary" type="button" onclick="encryptUI()">Encrypt & Show Steps</button>
        <button type="button" onclick="decryptUI()">Decrypt & Show Steps</button>
        <button class="ghost" type="button" onclick="clearUI()">Clear</button>

        <div class="result" id="resultBox" style="display:none;"></div>
      </div>

      <div class="col">
        <label for="cipher">Ciphertext (Base64) (for Decrypt)</label>
        <textarea id="cipher" rows="4" placeholder="Paste Base64 ciphertext here for decryption..."></textarea>

        <div class="steps" id="stepsBox" style="display:none;"></div>
      </div>
    </div>
  </div>

<script>

function StepsCollector() {
  const blocks = [];
  return {
    add(title, detailHtml) {
      blocks.push(`<div class="step-block"><div class="steptitle">${title}</div>${detailHtml || ""}</div>`);
    },
    html() { return blocks.join(""); },
    clear() { blocks.length = 0; }
  };
}
function hex2(b){ return b.toString(16).padStart(2,'0'); }
function bytesToHex(arr){ return Array.from(arr).map(hex2).join(''); }
function chunk(arr, n){
  const out = [];
  for (let i=0;i<arr.length;i+=n) out.push(arr.slice(i,i+n));
  return out;
}
function bytesToStateTable(stateBytes16){
  // AES state is 4x4 column-major: state[r][c] = bytes[r + 4*c]
  let html = '<table>';
  for (let r=0;r<4;r++){
    html += '<tr>';
    for (let c=0;c<4;c++){
      html += `<td>${hex2(stateBytes16[r + 4*c])}</td>`;
    }
    html += '</tr>';
  }
  html += '</table>';
  return html;
}
function showResult(html, stepsHtml){
  const r = document.getElementById('resultBox');
  r.innerHTML = html;
  r.style.display = 'block';
  const s = document.getElementById('stepsBox');
  s.innerHTML = stepsHtml || '';
  s.style.display = stepsHtml ? 'block' : 'none';
}
function clearUI(){
  document.getElementById('cipher').value = '';
  showResult('', '');
  document.getElementById('resultBox').style.display = 'none';
  document.getElementById('stepsBox').style.display = 'none';
}


function utf8ToBytes(str){
  return new TextEncoder().encode(str);
}
function bytesToUtf8(bytes){
  return new TextDecoder().decode(bytes);
}
function pkcs7Pad(bytes, blockSize=16){
  const rem = bytes.length % blockSize;
  const pad = (rem === 0) ? blockSize : (blockSize - rem);

  const out = new Uint8Array(bytes.length + pad);
  out.set(bytes, 0);
  out.fill(pad, bytes.length);
  return out;
}
function pkcs7Unpad(bytes){
  if (bytes.length === 0) throw new Error("Empty input");
  const pad = bytes[bytes.length-1];
  if (pad < 1 || pad > 16) throw new Error("Bad padding");
  for (let i=bytes.length-pad;i<bytes.length;i++){
    if (bytes[i] !== pad) throw new Error("Bad padding");
  }
  return bytes.slice(0, bytes.length-pad);
}

const SBOX = Uint8Array.from([
  0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
  0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
  0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
  0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
  0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
  0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
  0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
  0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
  0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
  0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
  0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
  0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
  0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
  0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
  0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
  0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
]);
const INV_SBOX = (() => {
  const inv = new Uint8Array(256);
  for (let i=0;i<256;i++) inv[SBOX[i]] = i;
  return inv;
})();

const RCON = Uint8Array.from([ // only need up to 10 for AES-128
  0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36
]);


function xtime(a){
  return ((a << 1) ^ ((a & 0x80) ? 0x1b : 0x00)) & 0xff;
}
function mul(a,b){
  // Russian peasant multiplication in GF(2^8)
  let p = 0;
  for (let i=0;i<8;i++){
    if (b & 1) p ^= a;
    const hi = a & 0x80;
    a = (a << 1) & 0xff;
    if (hi) a ^= 0x1b;
    b >>= 1;
  }
  return p;
}


function addRoundKey(state, roundKey16){
  for (let i=0;i<16;i++) state[i] ^= roundKey16[i];
}
function subBytes(state){
  for (let i=0;i<16;i++) state[i] = SBOX[state[i]];
}
function invSubBytes(state){
  for (let i=0;i<16;i++) state[i] = INV_SBOX[state[i]];
}
function shiftRows(state){
  // row r shifted left by r (state is column-major)
  const tmp = state.slice();
  // row 0 no change
  state[0]  = tmp[0];  state[4]  = tmp[4];  state[8]  = tmp[8];  state[12] = tmp[12];
  // row 1 shift left 1
  state[1]  = tmp[5];  state[5]  = tmp[9];  state[9]  = tmp[13]; state[13] = tmp[1];
  // row 2 shift left 2
  state[2]  = tmp[10]; state[6]  = tmp[14]; state[10] = tmp[2];  state[14] = tmp[6];
  // row 3 shift left 3
  state[3]  = tmp[15]; state[7]  = tmp[3];  state[11] = tmp[7];  state[15] = tmp[11];
}
function invShiftRows(state){
  const tmp = state.slice();
  state[0]  = tmp[0];  state[4]  = tmp[4];  state[8]  = tmp[8];  state[12] = tmp[12];
  // row 1 shift right 1
  state[1]  = tmp[13]; state[5]  = tmp[1];  state[9]  = tmp[5];  state[13] = tmp[9];
  // row 2 shift right 2
  state[2]  = tmp[10]; state[6]  = tmp[14]; state[10] = tmp[2];  state[14] = tmp[6];
  // row 3 shift right 3
  state[3]  = tmp[7];  state[7]  = tmp[11]; state[11] = tmp[15]; state[15] = tmp[3];
}
function mixColumns(state){
  for (let c=0;c<4;c++){
    const i = 4*c;
    const a0 = state[i], a1 = state[i+1], a2 = state[i+2], a3 = state[i+3];
    state[i]   = (mul(a0,2) ^ mul(a1,3) ^ a2 ^ a3) & 0xff;
    state[i+1] = (a0 ^ mul(a1,2) ^ mul(a2,3) ^ a3) & 0xff;
    state[i+2] = (a0 ^ a1 ^ mul(a2,2) ^ mul(a3,3)) & 0xff;
    state[i+3] = (mul(a0,3) ^ a1 ^ a2 ^ mul(a3,2)) & 0xff;
  }
}
function invMixColumns(state){
  for (let c=0;c<4;c++){
    const i = 4*c;
    const a0 = state[i], a1 = state[i+1], a2 = state[i+2], a3 = state[i+3];
    state[i]   = (mul(a0,14) ^ mul(a1,11) ^ mul(a2,13) ^ mul(a3,9)) & 0xff;
    state[i+1] = (mul(a0,9)  ^ mul(a1,14) ^ mul(a2,11) ^ mul(a3,13)) & 0xff;
    state[i+2] = (mul(a0,13) ^ mul(a1,9)  ^ mul(a2,14) ^ mul(a3,11)) & 0xff;
    state[i+3] = (mul(a0,11) ^ mul(a1,13) ^ mul(a2,9)  ^ mul(a3,14)) & 0xff;
  }
}


function rotWord(w4){ return [w4[1],w4[2],w4[3],w4[0]]; }
function subWord(w4){ return w4.map(b => SBOX[b]); }

function expandKeyAES128(key16, steps){
  // words w[0..43], each 4 bytes; round key r uses 4 words
  const w = new Array(44);
  for (let i=0;i<4;i++){
    w[i] = [key16[4*i], key16[4*i+1], key16[4*i+2], key16[4*i+3]];
  }

  for (let i=4;i<44;i++){
    let temp = w[i-1].slice();
    if (i % 4 === 0){
      temp = subWord(rotWord(temp));
      temp[0] ^= RCON[i/4];
    }
    w[i] = [
      w[i-4][0] ^ temp[0],
      w[i-4][1] ^ temp[1],
      w[i-4][2] ^ temp[2],
      w[i-4][3] ^ temp[3],
    ];
  }

  const roundKeys = [];
  for (let r=0;r<=10;r++){
    const rk = new Uint8Array(16);
    for (let i=0;i<4;i++){
      const word = w[4*r + i];
      rk[4*i] = word[0]; rk[4*i+1] = word[1]; rk[4*i+2] = word[2]; rk[4*i+3] = word[3];
    }
    roundKeys.push(rk);
  }

  if (steps){
    steps.add("KeyExpansion (AES-128)", `
      <div>Key (hex): <code>${bytesToHex(key16)}</code></div>
      <div>Round keys generated: <b>11</b> (K0..K10), each 16 bytes.</div>
      <div style="margin-top:8px; max-height:220px; overflow:auto; border:1px solid #e2e8f0; border-radius:8px; padding:8px; background:#fff;">
        ${roundKeys.map((rk, idx) => `<div><b>K${idx}:</b> <code>${bytesToHex(rk)}</code></div>`).join("")}
      </div>
    `);
  }

  return roundKeys;
}

function aesEncryptBlock128(block16, roundKeys, steps){
  const state = Uint8Array.from(block16);

  steps.add("Block input (16 bytes)", `<div>Hex: <code>${bytesToHex(state)}</code>${bytesToStateTable(state)}</div>`);

  // Round 0
  addRoundKey(state, roundKeys[0]);
  steps.add("Round 0: AddRoundKey (K0)", `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  // Rounds 1..9
  for (let r=1;r<=9;r++){
    subBytes(state);
    steps.add(`Round ${r}: SubBytes`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

    shiftRows(state);
    steps.add(`Round ${r}: ShiftRows`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

    mixColumns(state);
    steps.add(`Round ${r}: MixColumns`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

    addRoundKey(state, roundKeys[r]);
    steps.add(`Round ${r}: AddRoundKey (K${r})`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);
  }

  // Round 10 (no MixColumns)
  subBytes(state);
  steps.add(`Round 10: SubBytes`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  shiftRows(state);
  steps.add(`Round 10: ShiftRows`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  addRoundKey(state, roundKeys[10]);
  steps.add(`Round 10: AddRoundKey (K10)`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  steps.add("Block output (cipher, 16 bytes)", `<div>Hex: <code>${bytesToHex(state)}</code>${bytesToStateTable(state)}</div>`);

  return state;
}

function aesDecryptBlock128(block16, roundKeys, steps){
  const state = Uint8Array.from(block16);

  steps.add("Block input (cipher, 16 bytes)", `<div>Hex: <code>${bytesToHex(state)}</code>${bytesToStateTable(state)}</div>`);

  // Round 10 inverse start: AddRoundKey with K10
  addRoundKey(state, roundKeys[10]);
  steps.add("Round 10: AddRoundKey (K10)", `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  invShiftRows(state);
  steps.add("Round 10: InvShiftRows", `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  invSubBytes(state);
  steps.add("Round 10: InvSubBytes", `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  // Rounds 9..1
  for (let r=9;r>=1;r--){
    addRoundKey(state, roundKeys[r]);
    steps.add(`Round ${r}: AddRoundKey (K${r})`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

    invMixColumns(state);
    steps.add(`Round ${r}: InvMixColumns`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

    invShiftRows(state);
    steps.add(`Round ${r}: InvShiftRows`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

    invSubBytes(state);
    steps.add(`Round ${r}: InvSubBytes`, `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);
  }

  // Round 0: AddRoundKey with K0
  addRoundKey(state, roundKeys[0]);
  steps.add("Round 0: AddRoundKey (K0)", `<div>State:${bytesToStateTable(state)}</div><div>Hex: <code>${bytesToHex(state)}</code></div>`);

  steps.add("Block output (plain, 16 bytes)", `<div>Hex: <code>${bytesToHex(state)}</code>${bytesToStateTable(state)}</div>`);

  return state;
}

function normalizeKey16FromTextbox(str){
  const b = utf8ToBytes(str);
  const k = new Uint8Array(16);
  k.fill(0);
  k.set(b.slice(0,16), 0);
  return k;
}
function base64FromBytes(bytes){
  let bin = "";
  for (const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}
function bytesFromBase64(b64){
  const bin = atob(b64.trim());
  const out = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
  return out;
}

function encryptECBWithSteps(plaintext, keyStr){
  const steps = StepsCollector();
  const key16 = normalizeKey16FromTextbox(keyStr);

  steps.add("Mode/Format", `<div><b>AES-128</b>, ECB (educational), PKCS#7 padding, Ciphertext Base64.</div>`);

  const roundKeys = expandKeyAES128(key16, steps);

  const ptBytes = utf8ToBytes(plaintext);
  steps.add("Plaintext bytes (UTF-8)", `<div>Hex: <code>${bytesToHex(ptBytes)}</code></div><div>Length: ${ptBytes.length} bytes</div>`);

  const padded = pkcs7Pad(ptBytes, 16);
  steps.add("After PKCS#7 padding", `<div>Hex: <code>${bytesToHex(padded)}</code></div><div>Total length: ${padded.length} bytes (${padded.length/16} block(s))</div>`);

  const blocks = chunk(padded, 16);
  const out = new Uint8Array(padded.length);

  blocks.forEach((blk, idx) => {
    steps.add(`=== Encrypt Block ${idx} ===`, `<div>Block (hex): <code>${bytesToHex(blk)}</code></div>`);
    const c = aesEncryptBlock128(blk, roundKeys, steps);
    out.set(c, idx*16);
  });

  const b64 = base64FromBytes(out);
  return { ciphertextBytes: out, ciphertextBase64: b64, stepsHtml: steps.html() };
}

function decryptECBWithSteps(ciphertextBase64, keyStr){
  const steps = StepsCollector();
  const key16 = normalizeKey16FromTextbox(keyStr);

  steps.add("Mode/Format", `<div><b>AES-128</b>, ECB (educational), PKCS#7 unpadding, Ciphertext Base64.</div>`);

  const roundKeys = expandKeyAES128(key16, steps);

  const cbytes = bytesFromBase64(ciphertextBase64);
  if (cbytes.length % 16 !== 0) throw new Error("Ciphertext length must be a multiple of 16 bytes (invalid for AES block).");

  steps.add("Ciphertext bytes (from Base64)", `<div>Hex: <code>${bytesToHex(cbytes)}</code></div><div>Total length: ${cbytes.length} bytes (${cbytes.length/16} block(s))</div>`);

  const blocks = chunk(cbytes, 16);
  const out = new Uint8Array(cbytes.length);

  blocks.forEach((blk, idx) => {
    steps.add(`=== Decrypt Block ${idx} ===`, `<div>Block (hex): <code>${bytesToHex(blk)}</code></div>`);
    const p = aesDecryptBlock128(blk, roundKeys, steps);
    out.set(p, idx*16);
  });

  steps.add("Before PKCS#7 unpadding", `<div>Hex: <code>${bytesToHex(out)}</code></div>`);

  const unpadded = pkcs7Unpad(out);
  steps.add("After PKCS#7 unpadding", `<div>Hex: <code>${bytesToHex(unpadded)}</code></div><div>Length: ${unpadded.length} bytes</div>`);

  const plaintext = bytesToUtf8(unpadded);
  steps.add("Plaintext (UTF-8 decoded)", `<div><code>${plaintext.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")}</code></div>`);

  return { plaintext, stepsHtml: steps.html() };
}


function encryptUI(){
  try{
    const keyStr = document.getElementById('key').value;
    const plain = document.getElementById('plain').value;

    const { ciphertextBase64, stepsHtml } = encryptECBWithSteps(plain, keyStr);
    document.getElementById('cipher').value = ciphertextBase64;

    showResult(
      `<div><b>Ciphertext (Base64):</b> <code>${ciphertextBase64}</code></div>`,
      stepsHtml
    );
  } catch (e){
    showResult(`<div style="color:#b91c1c"><b>Error:</b> ${e.message}</div>`, "");
  }
}

function decryptUI(){
  try{
    const keyStr = document.getElementById('key').value;
    const b64 = document.getElementById('cipher').value;

    const { plaintext, stepsHtml } = decryptECBWithSteps(b64, keyStr);
    showResult(
      `<div><b>Plaintext:</b> <code>${plaintext.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")}</code></div>`,
      stepsHtml
    );
  } catch (e){
    showResult(`<div style="color:#b91c1c"><b>Error:</b> ${e.message}</div>`, "");
  }
}
</script>
</body>
</html>